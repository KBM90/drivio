import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:drivio_app/common/models/message.dart';
import 'package:flutter/material.dart';

class MessagingService {
  static final SupabaseClient _supabase = Supabase.instance.client;

  /// Generate chat ID from two user IDs (ensures consistent ID regardless of order)
  static String _getChatId(int userId1, int userId2) {
    final ids = [userId1, userId2]..sort();
    return 'chat_${ids[0]}_${ids[1]}';
  }

  /// Send a message
  static Future<bool> sendMessage({
    required int receiverId,
    required String message,
    required int senderId,
    String? senderName,
    String? senderRole,
  }) async {
    try {
      final chatId = _getChatId(senderId, receiverId);

      final messageData = Message(
        id: '', // Will be generated by Supabase
        chatId: chatId,
        senderId: senderId,
        receiverId: receiverId,
        message: message,
        timestamp: DateTime.now(),
        isRead: false,
        senderName: senderName,
        senderRole: senderRole,
      );

      // IMPORTANT: Create or update chat FIRST before inserting message
      // This ensures the chat exists for the foreign key constraint
      await _supabase.from('chats').upsert({
        'id': chatId,
        'participants': [senderId, receiverId],
        'last_message': message,
        'last_message_time': DateTime.now().toUtc().toIso8601String(),
        'last_sender_id': senderId,
        'created_at': DateTime.now().toUtc().toIso8601String(),
        'updated_at': DateTime.now().toUtc().toIso8601String(),
      });

      // Now insert the message (chat exists, so foreign key is satisfied)
      await _supabase.from('messages').insert(messageData.toMap());

      debugPrint('✅ Message sent successfully');
      return true;
    } catch (e) {
      debugPrint('❌ Error sending message: $e');
      return false;
    }
  }

  /// Listen to messages in real-time
  static Stream<List<Message>> getMessagesStream({
    required int currentUserId,
    required int otherUserId,
  }) {
    final chatId = _getChatId(currentUserId, otherUserId);

    return _supabase
        .from('messages')
        .stream(primaryKey: ['id'])
        .eq('chat_id', chatId)
        .order('timestamp', ascending: false)
        .map((data) {
          return data.map((messageData) {
            // Convert Supabase data to Message object
            return Message.fromSupabase(messageData);
          }).toList();
        });
  }

  /// Mark messages as read
  static Future<void> markMessagesAsRead({
    required int currentUserId,
    required int otherUserId,
  }) async {
    try {
      final chatId = _getChatId(currentUserId, otherUserId);

      // Update all unread messages from the other user
      await _supabase
          .from('messages')
          .update({'is_read': true})
          .eq('chat_id', chatId)
          .eq('receiver_id', currentUserId)
          .eq('is_read', false);

      debugPrint('✅ Messages marked as read');
    } catch (e) {
      debugPrint('❌ Error marking messages as read: $e');
    }
  }

  /// Get unread message count
  static Stream<int> getUnreadCountStream({
    required int currentUserId,
    required int otherUserId,
  }) {
    final chatId = _getChatId(currentUserId, otherUserId);

    return _supabase
        .from('messages')
        .stream(primaryKey: ['id'])
        .order('created_at')
        .map(
          (data) =>
              data
                  .where(
                    (m) =>
                        m['chat_id'] == chatId &&
                        m['receiver_id'] == currentUserId &&
                        m['is_read'] == false,
                  )
                  .length,
        );
  }

  /// Delete a message
  static Future<bool> deleteMessage({
    required int currentUserId,
    required int otherUserId,
    required String messageId,
  }) async {
    try {
      await _supabase.from('messages').delete().eq('id', messageId);

      debugPrint('✅ Message deleted');
      return true;
    } catch (e) {
      debugPrint('❌ Error deleting message: $e');
      return false;
    }
  }

  /// Get chat by ID (optional - useful for checking if chat exists)
  static Future<Map<String, dynamic>?> getChat({
    required int currentUserId,
    required int otherUserId,
  }) async {
    try {
      final chatId = _getChatId(currentUserId, otherUserId);

      final response =
          await _supabase.from('chats').select().eq('id', chatId).maybeSingle();

      return response;
    } catch (e) {
      debugPrint('❌ Error getting chat: $e');
      return null;
    }
  }
}
